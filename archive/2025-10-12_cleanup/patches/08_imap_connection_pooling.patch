--- /dev/null
+++ b/app/utils/imap_pool.py
@@ -0,0 +1,128 @@
+"""
+IMAP Connection Pooling for Email Management Tool
+Reduces connection overhead and improves reliability
+"""
+import threading
+import time
+import imaplib
+from contextlib import contextmanager
+from typing import Dict, Tuple
+from app.utils.crypto import decrypt_credential
+
+class IMAPConnectionPool:
+    """
+    Connection pool for IMAP connections.
+    Maintains reusable connections per account.
+    """
+
+    def __init__(self, max_connections_per_account=2, idle_timeout=300):
+        self._pools: Dict[int, list] = {}  # account_id -> [connection, ...]
+        self._locks: Dict[int, threading.Lock] = {}  # account_id -> lock
+        self._last_used: Dict[int, Dict] = {}  # account_id -> {conn: timestamp}
+        self.max_connections = max_connections_per_account
+        self.idle_timeout = idle_timeout
+        self._cleanup_thread = threading.Thread(target=self._cleanup_idle, daemon=True)
+        self._cleanup_thread.start()
+
+    def _create_connection(self, account_id: int, host: str, port: int, username: str, password: str, use_ssl: bool):
+        """Create new IMAP connection"""
+        try:
+            if use_ssl or port == 993:
+                imap = imaplib.IMAP4_SSL(host, port)
+            else:
+                imap = imaplib.IMAP4(host, port)
+                try:
+                    imap.starttls()
+                except Exception:
+                    pass  # STARTTLS not supported
+
+            imap.login(username, password)
+            return imap
+        except Exception as e:
+            raise RuntimeError(f"Failed to create IMAP connection: {e}")
+
+    @contextmanager
+    def get_connection(self, account_id: int, host: str, port: int, username: str, encrypted_password: str, use_ssl: bool = True):
+        """
+        Get connection from pool or create new one.
+        Usage:
+            with pool.get_connection(account_id, ...) as imap:
+                imap.select('INBOX')
+        """
+        # Ensure lock exists
+        if account_id not in self._locks:
+            self._locks[account_id] = threading.Lock()
+
+        # Decrypt password
+        password = decrypt_credential(encrypted_password)
+        if not password:
+            raise RuntimeError("Failed to decrypt password")
+
+        imap = None
+        with self._locks[account_id]:
+            # Initialize pool for account if needed
+            if account_id not in self._pools:
+                self._pools[account_id] = []
+                self._last_used[account_id] = {}
+
+            # Try to get existing connection
+            pool = self._pools[account_id]
+            while pool:
+                imap = pool.pop()
+                # Test if connection is still alive
+                try:
+                    imap.noop()
+                    break  # Connection is good
+                except Exception:
+                    # Connection dead, try next
+                    imap = None
+
+            # Create new connection if needed
+            if imap is None:
+                imap = self._create_connection(account_id, host, port, username, password, use_ssl)
+
+        # Connection acquired - yield to caller
+        try:
+            yield imap
+        finally:
+            # Return connection to pool
+            with self._locks[account_id]:
+                pool = self._pools[account_id]
+                if len(pool) < self.max_connections:
+                    # Test connection before returning to pool
+                    try:
+                        imap.noop()
+                        pool.append(imap)
+                        self._last_used[account_id][id(imap)] = time.time()
+                    except Exception:
+                        # Connection died during use, don't return to pool
+                        try:
+                            imap.logout()
+                        except Exception:
+                            pass
+                else:
+                    # Pool full, close connection
+                    try:
+                        imap.logout()
+                    except Exception:
+                        pass
+
+    def _cleanup_idle(self):
+        """Background thread to close idle connections"""
+        while True:
+            time.sleep(60)  # Check every minute
+            now = time.time()
+
+            for account_id in list(self._pools.keys()):
+                with self._locks[account_id]:
+                    pool = self._pools[account_id]
+                    last_used = self._last_used[account_id]
+
+                    # Close connections idle for > idle_timeout
+                    for conn in list(pool):
+                        if now - last_used.get(id(conn), now) > self.idle_timeout:
+                            pool.remove(conn)
+                            try:
+                                conn.logout()
+                            except Exception:
+                                pass
+
+# Global connection pool instance
+imap_pool = IMAPConnectionPool()

--- a/app/routes/interception.py
+++ b/app/routes/interception.py
@@ -20,6 +20,7 @@ from app.utils.db import get_db, DB_PATH
 from app.utils.crypto import decrypt_credential, encrypt_credential
 from app.utils.imap_helpers import _imap_connect_account, _ensure_quarantine, _move_uid_to_quarantine
+from app.utils.imap_pool import imap_pool

 bp_interception = Blueprint('interception_bp', __name__)

@@ -209,15 +210,20 @@ def api_interception_release(msg_id:int):
         msg = new_container
     decrypted_pass = decrypt_credential(row['imap_password'])
     try:
-        if row['imap_use_ssl']:
-            imap = imaplib.IMAP4_SSL(row['imap_host'], int(row['imap_port']))
-        else:
-            imap = imaplib.IMAP4(row['imap_host'], int(row['imap_port']))
-        if not decrypted_pass: raise RuntimeError('Decrypted password missing')
-        imap.login(row['imap_username'], decrypted_pass)
-        status,_ = imap.select(target_folder)
-        if status != 'OK': imap.select('INBOX')
-        # Use internaldate if available; else use current time; format via IMAP internal date
+        # Use connection pool for better performance and reliability
+        with imap_pool.get_connection(
+            account_id=row['account_id'],
+            host=row['imap_host'],
+            port=int(row['imap_port']),
+            username=row['imap_username'],
+            encrypted_password=row['imap_password'],
+            use_ssl=bool(row['imap_use_ssl'])
+        ) as imap:
+            status, _ = imap.select(target_folder)
+            if status != 'OK':
+                imap.select('INBOX')
+
+            # Use internaldate if available; else use current time
         date_param = None
         try:
             if row['original_internaldate']:
@@ -235,8 +241,8 @@ def api_interception_release(msg_id:int):
         except Exception:
             import time as _t
             date_param = imaplib.Time2Internaldate(_t.localtime())
-        # Append the (possibly edited) message
-        imap.append(target_folder, '', date_param, msg.as_bytes())
+            # Append the (possibly edited) message
+            imap.append(target_folder, '', date_param, msg.as_bytes())

         # Verify delivery using Message-ID header
         message_id_hdr = (msg.get('Message-ID') or '').strip()
@@ -253,10 +259,6 @@ def api_interception_release(msg_id:int):
             # If verification fails unexpectedly, mark as failed
             verify_ok = False

-        # All good; close IMAP
-        imap.logout()
     except Exception as e:
         import traceback
         traceback.print_exc()
