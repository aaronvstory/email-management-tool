{% extends "base.html" %}
{% import 'partials/account_components.html' as account_ui %}
{% import 'partials/rule_components.html' as rule_ui %}

{% block title %}Dashboard - Email Management Tool{% endblock %}

{% block extra_css %}
<style>
  /* Compact account selector */
  .account-selector {
    background: rgba(26,26,26,0.9);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 20px;
    box-shadow: 0 2px 4px -1px rgba(0,0,0,.6),0 1px 2px rgba(0,0,0,.4);
    border: 1px solid rgba(255,255,255,0.06);
  }

  .account-selector .selector-grid {
    display: grid;
    grid-template-columns: minmax(260px, 2fr) auto;
    grid-template-areas:
      "select actions"
      "meta meta";
    column-gap: 20px;
    row-gap: 14px;
    align-items: center;
  }

  .selector-field {
    grid-area: select;
  }

  .selector-field label {
    color: #9ca3af;
    font-weight: 500;
    margin-bottom: 6px;
    display: block;
    font-size: 0.85rem;
  }

  .selector-field select {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.12);
    color: #ffffff;
    width: 100%;
    padding: 10px 14px;
    border-radius: 8px;
    font-size: 0.95rem;
  }

  .selector-field select option {
    background: #1a1a1a;
    color: #ffffff;
  }

  .selector-meta {
    grid-area: meta;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
  }

  .selector-meta .selector-note {
    color: #9ca3af;
    font-size: 0.85rem;
    flex: 1 1 auto;
  }

  .selector-actions {
    grid-area: actions;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    justify-content: flex-end;
    gap: 6px;
  }

  .selector-actions .btn {
    min-width: 110px;
    justify-content: center;
  }

  .selector-actions label {
    color: #9ca3af;
    font-weight: 500;
    font-size: 0.85rem;
    margin: 0;
  }

  @media (max-width: 992px) {
    .account-selector .selector-grid {
      grid-template-columns: 1fr;
      grid-template-areas:
        "select"
        "meta"
        "actions";
      grid-template-columns: 1fr;
      align-items: stretch;
    }

    .selector-actions {
      justify-content: flex-start;
      align-items: flex-start;
      flex-direction: row;
      gap: 10px;
    }

    .selector-actions label {
      display: none;
    }
  }

  .stat-card {
    background: linear-gradient(145deg, #1a1a1a 0%, #1f1f1f 60%, #242424 100%);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 12px;
    padding: 15px;
    text-align: center;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .stat-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }

  .stat-value {
    font-size: 1.8rem;
    font-weight: 700;
    color: #ffffff;
    display: block;
    line-height: 1;
  }

  .stat-label {
    font-size: 0.75rem;
    color: #9ca3af;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 5px;
    display: block;
  }

  .stat-card.held .stat-value {
    color: #f87171;
  }

  .stat-card.released .stat-value {
    color: #34d399;
  }

  /* Recent emails section */
  .recent-emails-panel {
    background: linear-gradient(145deg, #1a1a1a 0%, #1f1f1f 60%, #242424 100%);
    border-radius: 18px;
    padding: 20px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.06);
  }

  #emailsList {
    max-height: 600px;
    overflow-y: auto;
    overflow-x: hidden;
    display: block;
    width: 100%;
  }

  #emailsList::-webkit-scrollbar {
    width: 8px;
  }

  #emailsList::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.03);
    border-radius: 4px;
  }

  #emailsList::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.15);
    border-radius: 4px;
  }

  #emailsList::-webkit-scrollbar-thumb:hover {
    background: rgba(255,255,255,0.25);
  }

  .panel-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #ffffff;
    margin-bottom: 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .email-list-item {
    display: grid;
    grid-template-columns: 280px 1fr 110px 180px;
    align-items: center;
    padding: 14px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    transition: background 0.2s;
    gap: 18px;
    width: 100%;
    box-sizing: border-box;
    min-height: 64px;
    max-width: 100%;
    overflow: hidden;
  }

  .email-list-item:hover {
    background: rgba(255,255,255,0.03);
    cursor: pointer;
  }

  .email-list-item:last-child {
    border-bottom: none;
  }

  .email-list-header {
    display: grid;
    grid-template-columns: 280px 1fr 110px 180px;
    gap: 18px;
    padding: 12px 14px;
    border-bottom: 2px solid rgba(255,255,255,0.08);
    background: rgba(255,255,255,0.02);
    margin-bottom: 6px;
  }

  .email-list-header > div {
    color: #9ca3af;
    font-weight: 600;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .email-correspondents {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .correspondent-line {
    display: flex;
    gap: 8px;
    align-items: baseline;
  }

  .correspondent-label {
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    color: #9ca3af;
    font-weight: 600;
    flex-shrink: 0;
    min-width: 42px;
  }

  .correspondent-value {
    color: #e5e7eb;
    font-size: 0.85rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex: 1 1 auto;
    min-width: 0;
  }

  .email-subject {
    color: #d1d5db;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    min-width: 0;
  }

  /* Status Tabs */
  .status-tabs {
    display: flex;
    gap: 8px;
    margin-bottom: 18px;
    flex-wrap: wrap;
    border-bottom: 1px solid rgba(255,255,255,0.08);
    padding-bottom: 10px;
  }

  .status-tab {
    padding: 10px 18px;
    border-radius: 8px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    color: #9ca3af;
    cursor: pointer;
    transition: all 0.2s ease;
    font-weight: 500;
    font-size: 0.9rem;
    display: inline-flex;
    align-items: center;
    gap: 8px;
  }

  .status-tab:hover {
    background: rgba(255,255,255,0.07);
    color: #ffffff;
  }

  .status-tab.active {
    background: rgba(127,29,29,0.16);
    border-color: rgba(127,29,29,0.32);
    color: #ffffff;
    box-shadow: none;
  }

  .status-tab .badge {
    background: rgba(255,255,255,0.12);
    padding: 2px 10px;
    border-radius: var(--radius-md);
    font-size: 0.75rem;
    font-weight: 600;
  }

  .status-tab.active .badge {
    background: rgba(255,255,255,0.2);
  }

  /* Filters Bar */
  .filters-bar {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 20px;
    align-items: center;
  }

  .search-group {
    flex: 1;
    min-width: 250px;
    position: relative;
    display: flex;
    align-items: center;
  }

  .search-group i {
    position: absolute;
    left: 12px;
    color: #9ca3af;
    pointer-events: none;
  }

  .search-input {
    flex: 1;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.12);
    color: #ffffff;
    padding: 10px 14px 10px 38px;
    border-radius: 8px;
    width: 100%;
  }

  .search-input::placeholder {
    color: #9ca3af;
  }

  .toolbar-actions {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .toolbar-actions .form-check {
    color: #ffffff;
    margin: 0;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  /* Email Table */
  .email-table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0;
  }

  .email-table thead th {
    background: rgba(255,255,255,0.03);
    color: #9ca3af;
    font-weight: 600;
    padding: 10px 12px;
    text-align: left;
    border-bottom: 2px solid rgba(255,255,255,0.06);
    font-size: 0.78rem;
    text-transform: uppercase;
    letter-spacing: 0.45px;
  }

  .email-table tbody tr {
    cursor: pointer;
    transition: background 0.2s;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }

  .email-table tbody tr:hover {
    background: rgba(255,255,255,0.05);
  }

  .email-table tbody td {
    padding: 10px 12px;
    color: #ffffff;
    vertical-align: middle;
    line-height: 1.35;
  }

  .subject-cell {
    font-size: 0.95rem;
    font-weight: 600;
    color: #ffffff;
  }

  .correspondent-cell {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .correspondent-line {
    display: flex;
    gap: 6px;
    align-items: flex-start;
    font-size: 0.82rem;
  }

  .correspondent-label {
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    color: #9ca3af;
    text-transform: uppercase;
    font-weight: 600;
    flex-shrink: 0;
    width: 45px;
  }

  .correspondent-value {
    color: #e5e7eb;
    line-height: 1.3;
    word-break: break-word;
  }

  /* Action Buttons */
  .action-buttons {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .action-btn {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color: #ffffff;
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 0.9rem;
  }

  .action-btn:hover {
    background: rgba(255,255,255,0.15);
  }

  .action-btn.action-release {
    background: rgba(16,185,129,0.15);
    border-color: rgba(16,185,129,0.3);
    color: #10b981;
  }

  .action-btn.action-release:hover {
    background: rgba(16,185,129,0.25);
  }

  .action-btn.action-discard,
  .action-btn.action-delete {
    background: rgba(239,68,68,0.15);
    border-color: rgba(239,68,68,0.3);
    color: #ef4444;
  }

  .action-btn.action-discard:hover,
  .action-btn.action-delete:hover {
    background: rgba(239,68,68,0.25);
  }

  .action-btn.action-edit {
    background: rgba(59,130,246,0.15);
    border-color: rgba(59,130,246,0.3);
    color: #3b82f6;
  }

  .action-btn.action-edit:hover {
    background: rgba(59,130,246,0.25);
  }

  .email-status {
    justify-self: center;
    text-align: center;
    width: 110px;
  }

  /* Consistent status badge styling */
  .email-status .status-badge {
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border: 1px solid;
    display: inline-block;
  }

  .email-time {
    color: #9ca3af;
    font-size: 0.9rem;
    white-space: nowrap;
    text-align: right;
    overflow: visible;
    text-overflow: initial;
    max-width: 200px;
  }

  .empty-state {
    text-align: center;
    padding: 40px 20px;
    color: #9ca3af;
  }

  .empty-state i {
    font-size: 3rem;
    color: #6b7280;
    margin-bottom: 15px;
  }

  /* Reduce header spacing */
  .page-header {
    margin-bottom: 15px !important;
  }

  /* Responsive adjustments for smaller screens */
  @media (max-width: 768px) {
    .email-list-header,
    .email-list-item {
      grid-template-columns: 1.2fr 1fr 90px 150px;
      gap: 14px;
      padding: 12px;
    }

    .correspondent-value {
      max-width: 220px;
    }

    .email-status {
      width: 90px;
    }

    .email-time {
      max-width: 150px;
      font-size: 0.82rem;
    }
  }

  @media (max-width: 576px) {
    .email-list-header,
    .email-list-item {
      grid-template-columns: minmax(0, 1fr) 1fr 75px;
      gap: 10px;
      padding: 10px;
    }

    .email-list-header > div:last-child,
    .email-time {
      display: none;
    }

    .email-status {
      width: 75px;
    }

    .correspondent-label {
      min-width: 38px;
    }

  }

</style>
{% endblock %}

{% block content %}
<div class="page-header">
  <div>
    <h1><i class="bi bi-speedometer2"></i> Dashboard</h1>
    <p class="text-muted mb-0">Track email activity and manage your monitored accounts.</p>
  </div>
  <div class="header-actions">
    <button class="btn btn-secondary btn-sm" type="button" onclick="location.reload()">
      <i class="bi bi-arrow-clockwise"></i> Refresh
    </button>
  </div>
</div>

<div class="account-selector">
  <div class="selector-grid">
    <div class="selector-field">
      <label for="accountSelector">Filter by account</label>
      <select class="form-select" id="accountSelector" onchange="switchAccount(this.value)">
        <option value="">All accounts</option>
        {% for account in accounts %}
        <option value="{{ account.id }}" {% if selected_account_id == account.id|string %}selected{% endif %}>
          {{ account.account_name }} ({{ account.email_address }})
        </option>
        {% endfor %}
      </select>
    </div>

    <div class="selector-meta">
      {% if selected_account_id %}
        {% for account in accounts %}
          {% if account.id|string == selected_account_id %}
          <span class="tag-chip {% if account.is_active %}success{% else %}accent{% endif %}">
            {% if account.is_active %}Active{% else %}Inactive{% endif %}
          </span>
          {% if account.last_checked %}
          <span class="selector-note">
            Last checked: <span class="time-cell" data-ts="{{ account.last_checked }}">{{ account.last_checked }}</span>
          </span>
          {% else %}
          <span class="selector-note">Last checked: Never</span>
          {% endif %}
          {% endif %}
        {% endfor %}
      {% else %}
        <span class="selector-note">Showing aggregated telemetry across all monitored accounts.</span>
      {% endif %}
    </div>

    <div class="selector-actions">
      <label class="form-label">Actions</label>
      <a href="{{ url_for('accounts.email_accounts') }}" class="btn btn-ghost btn-sm">
        <i class="bi bi-gear"></i> Manage
      </a>
    </div>
  </div>
</div>

{% set totals = namespace(value = stats.total if stats.total is not none else 0, held = 0, released = 0) %}
{% set totals.held = stats.held|default(0) %}
{% set totals.released = stats.released|default(0) %}
{% if totals.value == 0 %}
  {% set totals.value = totals.held + totals.released + (stats.rejected|default(0)) + (stats.discarded|default(0)) %}
{% endif %}

<!-- Compact Stats Grid -->
<div class="stats-grid" id="statsGrid">
  <div class="stat-card-modern">
    <span class="stat-value" id="statTotal">{{ totals.value }}</span>
    <span class="stat-label">Total</span>
  </div>
  <div class="stat-card-modern held">
    <span class="stat-value" id="statHeld">{{ totals.held }}</span>
    <span class="stat-label">Held</span>
  </div>
  <div class="stat-card-modern released">
    <span class="stat-value" id="statReleased">{{ totals.released }}</span>
    <span class="stat-label">Released</span>
  </div>
</div>

<!-- Recent Emails -->
<div class="recent-emails-panel">
  <div class="panel-title">
    <span><i class="bi bi-envelope"></i> Recent Emails</span>
    <a href="{{ url_for('emails.emails_unified') }}" class="btn btn-ghost btn-sm">
      View All <i class="bi bi-arrow-right"></i>
    </a>
  </div>

  <!-- Filter Tabs -->
  <div class="status-tabs">
    <button class="status-tab active" data-status="ALL" onclick="switchDashboardFilter('ALL')">
      <i class="bi bi-inbox"></i> All
      <span class="badge" id="dashboard-badge-all">0</span>
    </button>
    <button class="status-tab" data-status="HELD" onclick="switchDashboardFilter('HELD')">
      <i class="bi bi-hand-stop"></i> Held
      <span class="badge" id="dashboard-badge-held">0</span>
    </button>
    <button class="status-tab" data-status="RELEASED" onclick="switchDashboardFilter('RELEASED')">
      <i class="bi bi-send-check"></i> Released
      <span class="badge" id="dashboard-badge-released">0</span>
    </button>
    <button class="status-tab" data-status="REJECTED" onclick="switchDashboardFilter('REJECTED')">
      <i class="bi bi-x-circle"></i> Rejected
      <span class="badge" id="dashboard-badge-rejected">0</span>
    </button>
  </div>

  <!-- Search and Controls -->
  <div class="filters-bar">
    <div class="search-group">
      <i class="bi bi-search"></i>
      <input id="dashboardSearchBox" class="search-input" placeholder="Search subject, sender, or recipient..." oninput="filterDashboardEmails()" />
    </div>
    <div class="toolbar-actions">
      <label class="form-check">
        <input type="checkbox" class="form-check-input" id="dashboardAutoRefresh" onchange="toggleDashboardAutoRefresh(this.checked)">
        <span>Auto-refresh</span>
      </label>
      <button class="btn-secondary" type="button" onclick="loadDashboardEmails()">
        <i class="bi bi-arrow-clockwise"></i> Refresh
      </button>
    </div>
  </div>

  <!-- Email Table -->
  <div style="overflow-x: auto;">
    <table class="email-table">
      <thead>
        <tr>
          <th style="width: 150px;">Time</th>
          <th style="width: 260px;">Correspondents</th>
          <th>Subject</th>
          <th style="width: 120px;">Status</th>
          <th style="width: 150px;">Actions</th>
        </tr>
      </thead>
      <tbody id="dashboardEmailTableBody">
        <!-- Dynamic content loaded via JavaScript -->
      </tbody>
    </table>
  </div>

  <!-- Empty State -->
  <div id="dashboardEmptyState" class="empty-state" style="display: none;">
    <i class="bi bi-inbox"></i>
    <p>No emails found</p>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
const currentAccountId = '{{ selected_account_id or "" }}';
const { renderTimeCell, applyTimeFormatting } = window.MailOps;

applyTimeFormatting();

let dashboardAggregateCounts = null;
let dashboardDatasetCounts = { ALL: 0, HELD: 0, RELEASED: 0, REJECTED: 0 };

function updateStatsFromPayload(payload) {
  if (!payload) return;
  const toNumber = (value) => {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : 0;
  };

  const hasAggregateFields = ['total', 'held', 'released', 'rejected', 'discarded'].some(
    (key) => Object.prototype.hasOwnProperty.call(payload, key)
  );

  // Ignore partial SSE payloads that only contain incremental fields (e.g., pending count)
  if (!hasAggregateFields) {
    return;
  }

  const heldTotal = toNumber(payload.held);
  const releasedTotal = toNumber(payload.released);
  const totalCandidate = toNumber(payload.total);
  const rejectedTotal = toNumber(payload.rejected) + toNumber(payload.discarded);
  const totalValue = totalCandidate > 0 ? totalCandidate : heldTotal + releasedTotal + rejectedTotal;

  document.getElementById('statTotal').textContent = totalValue;
  document.getElementById('statHeld').textContent = heldTotal;
  document.getElementById('statReleased').textContent = releasedTotal;

  dashboardAggregateCounts = {
    ALL: totalValue,
    HELD: heldTotal,
    RELEASED: releasedTotal,
    REJECTED: rejectedTotal
  };
  applyDashboardBadgeCounts();
}

function switchAccount(accountId) {
  currentAccountId = accountId;
  const searchParams = accountId ? '?account_id=' + accountId : '';
  window.location.href = `/dashboard${searchParams}`;
}

// Load stats with account filtering
async function loadStats() {
  try {
    let url = '/api/unified-stats';
    if (currentAccountId) {
      url += '?account_id=' + currentAccountId;
    }

    const response = await fetch(url);
    if (!response.ok) return;

    const data = await response.json();
    const payload = data && data.unified ? data.unified : data;
    updateStatsFromPayload(payload || {});
  } catch (error) {
    console.error('Error loading stats:', error);
  }
}

// Load watcher states for all accounts
async function loadWatchersMap() {
  try {
    const r = await fetch('/api/watchers/overview');
    if (!r.ok) return;
    const j = await r.json();
    watchersMap = {};
    (j.accounts || []).forEach(a => {
      watchersMap[a.id] = (a.watcher && a.watcher.state) || (a.is_active ? 'active' : 'stopped');
    });
  } catch (e) { /* ignore */ }
}

// Dashboard email management
let dashboardEmails = [];
let dashboardActiveFilter = 'ALL';
let dashboardAutoRefreshTimer = null;
let watchersMap = {};
const { escapeHtml } = window.MailOps || { escapeHtml: (s) => String(s).replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])) };

// Load recent emails with account filtering
async function loadDashboardEmails() {
  try {
    let url = '/api/inbox';
    const params = new URLSearchParams();
    if (currentAccountId) {
      params.append('account_id', currentAccountId);
    }
    params.append('limit', '50');

    const response = await fetch(url + '?' + params.toString());
    if (!response.ok) throw new Error('Failed to fetch emails');

    const data = await response.json();
    dashboardEmails = data.messages || [];
    
    updateDashboardBadges(dashboardEmails);
    filterDashboardEmails(dashboardActiveFilter);
  } catch (error) {
    console.error('Error loading emails:', error);
  }
}

// Restart watcher for a specific account
async function restartWatcherFor(accountId) {
  if (!accountId) {
    if (window.showError) showError('No account ID available for watcher restart');
    return;
  }
  try {
    const r = await fetch(`/api/accounts/${accountId}/monitor/restart`, { method: 'POST' });
    const j = await r.json();
    if (!j.success) {
      throw new Error(j.error || 'Failed');
    }
    if (window.showSuccess) showSuccess('Watcher restarted');
    await loadWatchersMap();
    filterDashboardEmails(dashboardActiveFilter);
  } catch (e) {
    if (window.showError) showError('Restart failed (admin required?)');
  }
}

function updateDashboardBadges(emails) {
  const counts = { ALL: 0, HELD: 0, RELEASED: 0, REJECTED: 0 };
  emails.forEach(email => {
    counts.ALL++;
    let status = (email.interception_status || email.status || '').toUpperCase();
    if (status === 'PENDING') status = 'HELD';
    if (status === 'APPROVED' || status === 'DELIVERED') status = 'RELEASED';
    if (status === 'DISCARDED') status = 'REJECTED';
    if (counts[status] !== undefined) counts[status]++;
  });
  dashboardDatasetCounts = counts;
  applyDashboardBadgeCounts();
}

function applyDashboardBadgeCounts() {
  const dataset = dashboardDatasetCounts || {};
  const aggregate = dashboardAggregateCounts || null;
  const useAggregate = aggregate && (aggregate.ALL || aggregate.HELD || aggregate.RELEASED || aggregate.REJECTED);

  const finalAll = useAggregate ? aggregate.ALL : (dataset.ALL || 0);
  const finalHeld = useAggregate ? aggregate.HELD : (dataset.HELD || 0);
  const finalReleased = useAggregate ? aggregate.RELEASED : (dataset.RELEASED || 0);
  const finalRejected = useAggregate ? aggregate.REJECTED : (dataset.REJECTED || 0);

  document.getElementById('dashboard-badge-all').textContent = finalAll;
  document.getElementById('dashboard-badge-held').textContent = finalHeld;
  document.getElementById('dashboard-badge-released').textContent = finalReleased;
  document.getElementById('dashboard-badge-rejected').textContent = finalRejected;
}

function switchDashboardFilter(status) {
  dashboardActiveFilter = status;
  document.querySelectorAll('.status-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.status === status);
  });
  filterDashboardEmails(status);
}

function filterDashboardEmails(statusFilter = dashboardActiveFilter) {
  const searchTerm = document.getElementById('dashboardSearchBox').value.toLowerCase();
  let filtered = dashboardEmails;
  
  // Filter by status
  if (statusFilter && statusFilter !== 'ALL') {
    filtered = filtered.filter(email => {
      let status = (email.interception_status || email.status || '').toUpperCase();
      if (status === 'PENDING') status = 'HELD';
      if (status === 'APPROVED' || status === 'DELIVERED') status = 'RELEASED';
      if (status === 'DISCARDED') status = 'REJECTED';
      return status === statusFilter;
    });
  }
  
  // Filter by search
  if (searchTerm) {
    filtered = filtered.filter(email => {
      const subject = (email.subject || '').toLowerCase();
      const sender = (email.sender || '').toLowerCase();
      const recipients = Array.isArray(email.recipients) ? email.recipients.join(' ').toLowerCase() : (email.recipients || '').toLowerCase();
      return subject.includes(searchTerm) || sender.includes(searchTerm) || recipients.includes(searchTerm);
    });
  }
  
  renderDashboardEmails(filtered);
}

function renderDashboardEmails(emails) {
  const tbody = document.getElementById('dashboardEmailTableBody');
  const emptyState = document.getElementById('dashboardEmptyState');
  
  if (!emails || emails.length === 0) {
    tbody.innerHTML = '';
    emptyState.style.display = 'block';
    return;
  }
  
  emptyState.style.display = 'none';
  tbody.innerHTML = '';
  
  emails.slice(0, 20).forEach(email => {
    const tr = document.createElement('tr');
    tr.dataset.emailId = email.id;
    
    let status = (email.interception_status || email.status || 'UNKNOWN').toUpperCase();
    if (status === 'PENDING') status = 'HELD';
    if (status === 'APPROVED' || status === 'DELIVERED') status = 'RELEASED';
    if (status === 'DISCARDED') status = 'REJECTED';
    const statusLabel = status.charAt(0) + status.slice(1).toLowerCase();
    
    const recipients = Array.isArray(email.recipients) ? email.recipients.join(', ') : (email.recipients || '');
    const senderDisplay = escapeHtml(email.sender || 'Unknown');
    const recipientDisplay = escapeHtml(recipients || 'â€”');
    const subjectDisplay = escapeHtml(email.subject || '(No Subject)');
    const createdAtCell = renderTimeCell(email.created_at, 'N/A');
    
    // Determine actions
    let actions = '';
    if (status === 'HELD') {
      actions = `
        <button class="action-btn action-edit" onclick="event.stopPropagation(); window.location.href='/email/${email.id}'" title="Edit">
          <i class="bi bi-pencil"></i>
        </button>
        <button class="action-btn action-release" onclick="event.stopPropagation(); releaseEmailDashboard(${email.id})" title="Release">
          <i class="bi bi-unlock"></i>
        </button>
        <button class="action-btn action-discard" onclick="event.stopPropagation(); discardEmailDashboard(${email.id})" title="Discard">
          <i class="bi bi-trash"></i>
        </button>
      `;
    } else {
      actions = `
        <button class="action-btn action-view" onclick="event.stopPropagation(); window.location.href='/email/${email.id}'" title="View">
          <i class="bi bi-eye"></i>
        </button>
      `;
    }
    
    // Generate watcher badge
    const watcherStateRaw = watchersMap[email.account_id] || 'unknown';
    const watcherClass = watcherStateRaw === 'active' ? 'active' : (watcherStateRaw === 'stopped' ? 'stopped' : 'unknown');
    let watcherLabel = 'Unknown';
    if (watcherStateRaw === 'active') {
      watcherLabel = 'Active';
    } else if (watcherStateRaw === 'stopped') {
      watcherLabel = 'Stopped';
    } else if (watcherStateRaw && watcherStateRaw !== 'unknown') {
      watcherLabel = watcherStateRaw.charAt(0).toUpperCase() + watcherStateRaw.slice(1);
    }
    const watcherClassSafe = escapeHtml(watcherClass);
    const watcherBadge = `<span class="watcher-chip ${watcherClassSafe}" title="Watcher state">${escapeHtml(watcherLabel)}</span>`;
    
    tr.innerHTML = `
      <td>${createdAtCell}</td>
      <td>
        <div class="correspondent-cell">
          <div class="correspondent-line">
            <span class="correspondent-label">FROM</span>
            <span class="correspondent-value">${senderDisplay}</span>
          </div>
          <div class="correspondent-line">
            <span class="correspondent-label">TO</span>
            <span class="correspondent-value">${recipientDisplay}</span>
          </div>
        </div>
      </td>
      <td onclick="window.location.href='/email/${email.id}'" style="cursor: pointer;">
        <div class="subject-cell">${subjectDisplay}</div>
      </td>
      <td>
        <div class="status-cell">
          <div class="status-main"><span class="status-badge status-${status}">${statusLabel}</span></div>
          <div class="status-meta">${watcherBadge}
            <button type="button" class="status-restart" title="Restart watcher" onclick="restartWatcherFor(${email.account_id})"><i class="bi bi-arrow-repeat"></i></button>
          </div>
        </div>
      </td>
      <td>
        <div class="action-buttons">
          ${actions}
        </div>
      </td>
    `;
    
    tbody.appendChild(tr);
  });
  
  applyTimeFormatting(tbody);
}

async function releaseEmailDashboard(emailId) {
  if (!confirm('Release this email to the inbox?')) return;
  try {
    const response = await fetch(`/api/interception/release/${emailId}`, { method: 'POST' });
    const data = await response.json();
    if (data.success) {
      if (window.showSuccess) showSuccess('Email released successfully');
      await loadDashboardEmails();
      await loadStats();
    } else {
      if (window.showError) showError(data.error || 'Failed to release email');
    }
  } catch (error) {
    console.error('Error releasing email:', error);
    if (window.showError) showError('Failed to release email');
  }
}

async function discardEmailDashboard(emailId) {
  if (!confirm('Discard this email permanently?')) return;
  try {
    const response = await fetch(`/api/interception/discard/${emailId}`, { method: 'POST' });
    const data = await response.json();
    if (data.success) {
      if (window.showSuccess) showSuccess('Email discarded');
      await loadDashboardEmails();
      await loadStats();
    } else {
      if (window.showError) showError(data.error || 'Failed to discard email');
    }
  } catch (error) {
    console.error('Error discarding email:', error);
    if (window.showError) showError('Failed to discard email');
  }
}

function toggleDashboardAutoRefresh(enabled) {
  if (dashboardAutoRefreshTimer) {
    clearInterval(dashboardAutoRefreshTimer);
    dashboardAutoRefreshTimer = null;
  }
  
  if (enabled) {
    dashboardAutoRefreshTimer = setInterval(() => {
      loadDashboardEmails();
      loadStats();
    }, 10000); // Refresh every 10 seconds
  }
  
  localStorage.setItem('dashboard_auto_refresh', enabled ? 'true' : 'false');
}

// Initialize and set up auto-refresh
loadStats();
loadWatchersMap();
loadDashboardEmails();

// Restore auto-refresh preference
const dashboardAutoRefreshPref = localStorage.getItem('dashboard_auto_refresh');
if (dashboardAutoRefreshPref === 'true') {
  document.getElementById('dashboardAutoRefresh').checked = true;
  toggleDashboardAutoRefresh(true);
}

// Auto-refresh every 30 seconds
setInterval(() => {
  loadStats();
  loadWatchersMap();
  loadDashboardEmails();
}, 30000);

// Try to use SSE for real-time updates
try {
  const eventSource = new EventSource('/stream/stats');

  eventSource.onmessage = (event) => {
    try {
      const raw = JSON.parse(event.data);
      const payload = raw && raw.unified ? raw.unified : raw;
      const targetAccount = raw && raw.account_id !== undefined
        ? String(raw.account_id)
        : (payload && payload.account_id !== undefined ? String(payload.account_id) : null);

      if (!currentAccountId || targetAccount === null || String(currentAccountId) === targetAccount) {
        updateStatsFromPayload(payload || {});
      }
    } catch (err) {
      console.warn('SSE parse error:', err);
    }
  };

  eventSource.onerror = () => {
    eventSource.close();
    // Fall back to polling
  };
} catch (error) {
  console.warn('SSE not supported, using polling');
}
</script>
{% endblock %}



