{% extends "base.html" %}
{% import 'partials/account_components.html' as account_ui %}
{% import 'partials/rule_components.html' as rule_ui %}

{% block title %}Dashboard - Email Management Tool{% endblock %}

{% block extra_css %}
<!-- Stitch dashboard uses Tailwind from base.html -->
{% endblock %}

{% block content %}
<div id="dashboard-page" class="tw-p-6 md:tw-p-8 tw-space-y-8 tw-bg-[#18181b] tw-min-h-screen">
<div class="page-header tw-flex tw-flex-col md:tw-flex-row md:tw-items-start md:tw-justify-between tw-gap-4 tw-border-b tw-border-[#27272a] tw-pb-6">
  <div>
    <h1 class="tw-text-3xl tw-font-bold tw-text-[#f4f4f5]">
      <i class="bi bi-speedometer2"></i> Dashboard
    </h1>
    <p class="tw-mt-2 tw-text-[#a1a1aa]">Track email activity and manage your monitored accounts.</p>
  </div>
  <div class="header-actions">
    <button class="tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-font-medium tw-py-2 tw-px-4 hover:tw-bg-zinc-700 tw-transition-colors tw-flex tw-items-center tw-gap-2 tw-rounded-md" type="button" onclick="location.reload()">
      <i class="bi bi-arrow-clockwise"></i> Refresh
    </button>
  </div>
</div>

<div class="account-selector tw-bg-[#18181b] tw-border tw-border-[#27272a] tw-rounded-md tw-p-5">
  <div class="selector-grid tw-grid tw-grid-cols-1 md:tw-grid-cols-[1fr_auto_auto] tw-gap-4 tw-items-center">
    <div class="selector-field">
      <label for="accountSelector" class="tw-block tw-text-sm tw-font-medium tw-text-[#a1a1aa] tw-mb-2">Filter by account</label>
      <select class="form-select tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-rounded-md tw-px-3 tw-py-2" id="accountSelector" onchange="switchAccount(this.value)">
        <option value="">All accounts</option>
        {% for account in accounts %}
        <option value="{{ account.id }}" {% if selected_account_id == account.id|string %}selected{% endif %}>
          {{ account.account_name }} ({{ account.email_address }})
        </option>
        {% endfor %}
      </select>
    </div>

    <div class="selector-meta tw-flex tw-items-center tw-gap-3">
      {% if selected_account_id %}
        {% for account in accounts %}
          {% if account.id|string == selected_account_id %}
          <span class="tw-inline-flex tw-items-center tw-text-xs tw-font-medium tw-px-2 tw-py-1 {% if account.is_active %}tw-bg-[#bef264]/10 tw-text-[#bef264]{% else %}tw-bg-zinc-700/50 tw-text-[#a1a1aa]{% endif %} tw-rounded-md">
            {% if account.is_active %}Active{% else %}Inactive{% endif %}
          </span>
          {% if account.last_checked %}
          <span class="tw-text-sm tw-text-[#a1a1aa]">
            Last: <span class="time-cell" data-ts="{{ account.last_checked }}">{{ account.last_checked }}</span>
          </span>
          {% else %}
          <span class="tw-text-sm tw-text-[#a1a1aa]">Never checked</span>
          {% endif %}
          {% endif %}
        {% endfor %}
      {% else %}
        <span class="tw-text-sm tw-text-[#a1a1aa]">Showing all monitored accounts</span>
      {% endif %}
    </div>

    <div class="selector-actions">
      <a href="{{ url_for('accounts.email_accounts') }}" class="tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-font-medium tw-py-2 tw-px-4 hover:tw-bg-zinc-700 tw-transition-colors tw-flex tw-items-center tw-gap-2 tw-rounded-md">
        <i class="bi bi-gear"></i> Manage
      </a>
    </div>
  </div>
</div>

{% set totals = namespace(value = stats.total if stats.total is not none else 0, held = 0, released = 0) %}
{% set totals.held = stats.held|default(0) %}
{% set totals.released = stats.released|default(0) %}
{% if totals.value == 0 %}
  {% set totals.value = totals.held + totals.released + (stats.rejected|default(0)) + (stats.discarded|default(0)) %}
{% endif %}

<!-- Stitch Stats Grid -->
<div class="stats-grid tw-grid tw-grid-cols-1 md:tw-grid-cols-2 lg:tw-grid-cols-4 tw-gap-6" id="statsGrid">
  <div class="stat-card-modern tw-bg-[#18181b] tw-p-5 tw-border tw-border-[#27272a] tw-rounded-md">
    <div class="tw-flex tw-items-center tw-justify-between">
      <h3 class="tw-text-sm tw-font-medium tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider">Emails Processed</h3>
      <span class="material-symbols-outlined tw-text-[#a1a1aa]">mail</span>
    </div>
    <p class="stat-value tw-text-3xl tw-font-bold tw-text-[#f4f4f5] tw-mt-4" id="statTotal">{{ totals.value }}</p>
  </div>
  <div class="stat-card-modern held tw-bg-[#18181b] tw-p-5 tw-border tw-border-[#27272a] tw-rounded-md">
    <div class="tw-flex tw-items-center tw-justify-between">
      <h3 class="tw-text-sm tw-font-medium tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider">Emails Held</h3>
      <span class="material-symbols-outlined tw-text-[#a1a1aa]">pause_circle</span>
    </div>
    <p class="stat-value tw-text-3xl tw-font-bold tw-text-[#f4f4f5] tw-mt-4" id="statHeld">{{ totals.held }}</p>
    <p class="tw-text-xs tw-text-yellow-400 tw-flex tw-items-center tw-gap-1 tw-mt-1">
      <span class="material-symbols-outlined tw-text-base">warning</span>
      Pending review
    </p>
  </div>
  <div class="stat-card-modern released tw-bg-[#18181b] tw-p-5 tw-border tw-border-[#27272a] tw-rounded-md">
    <div class="tw-flex tw-items-center tw-justify-between">
      <h3 class="tw-text-sm tw-font-medium tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider">Emails Released</h3>
      <span class="material-symbols-outlined tw-text-[#a1a1aa]">send</span>
    </div>
    <p class="stat-value tw-text-3xl tw-font-bold tw-text-[#f4f4f5] tw-mt-4" id="statReleased">{{ totals.released }}</p>
    <p class="tw-text-xs tw-text-[#bef264] tw-flex tw-items-center tw-gap-1 tw-mt-1">
      <span class="material-symbols-outlined tw-text-base">arrow_upward</span>
      Delivered
    </p>
  </div>
  <div class="stat-card-modern tw-bg-[#18181b] tw-p-5 tw-border tw-border-[#27272a] tw-rounded-md">
    <div class="tw-flex tw-items-center tw-justify-between">
      <h3 class="tw-text-sm tw-font-medium tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider">Watchers Active</h3>
      <span class="material-symbols-outlined tw-text-[#a1a1aa]">visibility</span>
    </div>
    <p class="stat-value tw-text-3xl tw-font-bold tw-text-[#f4f4f5] tw-mt-4" id="statWatchers">--</p>
    <p class="tw-text-xs tw-text-[#a1a1aa] tw-mt-1 tw-h-5"> </p>
  </div>
</div>

<!-- Recent Emails Panel -->
<div class="recent-emails-panel tw-bg-[#18181b] tw-border tw-border-[#27272a] tw-rounded-md">
  <div class="panel-title tw-p-4 tw-border-b tw-border-[#27272a] tw-flex tw-items-center tw-justify-between">
    <h2 class="tw-text-lg tw-font-bold tw-text-[#f4f4f5]">
      <i class="bi bi-envelope"></i> Recent Emails Held
    </h2>
    <a href="{{ url_for('emails.emails_unified') }}" class="tw-text-[#bef264] hover:tw-text-[#bef264]/90 tw-font-medium tw-text-sm tw-flex tw-items-center tw-gap-1">
      View All
      <span class="material-symbols-outlined tw-text-lg">arrow_forward</span>
    </a>
  </div>

  <!-- Search Bar -->
  <div class="tw-p-4 tw-border-b tw-border-[#27272a]">
    <div class="tw-flex tw-gap-2">
      <input type="text" id="email-search-input" class="tw-flex-1 tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-rounded-md tw-px-3 tw-py-2 focus:tw-outline-none focus:tw-ring-2 focus:tw-ring-[#bef264]/50" placeholder="Search emails by subject, sender, recipient, or content...">
      <button class="tw-bg-[#bef264] tw-text-zinc-900 tw-font-bold tw-py-2 tw-px-4 hover:tw-bg-[#bef264]/90 tw-transition-colors tw-flex tw-items-center tw-gap-2 tw-rounded-md" id="email-search-btn" onclick="performEmailSearch()">
        <i class="bi bi-search"></i> Search
      </button>
      <button class="tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-font-medium tw-py-2 tw-px-4 hover:tw-bg-zinc-700 tw-transition-colors tw-rounded-md" id="email-search-clear" onclick="clearEmailSearch()" style="display:none;">
        <i class="bi bi-x-circle"></i> Clear
      </button>
    </div>
    <div id="email-search-results" style="display:none; margin-top:12px;">
      <div class="alert alert-info" id="email-search-status"></div>
    </div>
  </div>

  <!-- Filter Tabs -->
  <div class="status-tabs tw-p-4 tw-flex tw-flex-wrap tw-gap-2 tw-border-b tw-border-[#27272a]">
    <button class="status-tab active tw-inline-flex tw-items-center tw-gap-2 tw-rounded-full tw-border tw-border-[#27272a] tw-bg-[#bef264]/20 tw-border-[#bef264]/30 tw-text-[#bef264] tw-px-4 tw-py-2 tw-text-sm hover:tw-bg-[#bef264]/30 tw-transition-colors" data-status="ALL" onclick="switchDashboardFilter('ALL')">
      <i class="bi bi-inbox"></i> All
      <span class="badge tw-ml-1 tw-rounded-full tw-bg-white/10 tw-px-2 tw-py-0.5 tw-text-[11px]" id="dashboard-badge-all">0</span>
    </button>
    <button class="status-tab tw-inline-flex tw-items-center tw-gap-2 tw-rounded-full tw-border tw-border-[#27272a] tw-bg-[#18181b] hover:tw-bg-[#27272a]/50 tw-px-4 tw-py-2 tw-text-sm tw-text-[#a1a1aa] hover:tw-text-[#f4f4f5] tw-transition-colors" data-status="HELD" onclick="switchDashboardFilter('HELD')">
      <i class="bi bi-hand-stop"></i> Held
      <span class="badge tw-ml-1 tw-rounded-full tw-bg-white/10 tw-px-2 tw-py-0.5 tw-text-[11px]" id="dashboard-badge-held">0</span>
    </button>
    <button class="status-tab tw-inline-flex tw-items-center tw-gap-2 tw-rounded-full tw-border tw-border-[#27272a] tw-bg-[#18181b] hover:tw-bg-[#27272a]/50 tw-px-4 tw-py-2 tw-text-sm tw-text-[#a1a1aa] hover:tw-text-[#f4f4f5] tw-transition-colors" data-status="RELEASED" onclick="switchDashboardFilter('RELEASED')">
      <i class="bi bi-send-check"></i> Released
      <span class="badge tw-ml-1 tw-rounded-full tw-bg-white/10 tw-px-2 tw-py-0.5 tw-text-[11px]" id="dashboard-badge-released">0</span>
    </button>
    <button class="status-tab tw-inline-flex tw-items-center tw-gap-2 tw-rounded-full tw-border tw-border-[#27272a] tw-bg-[#18181b] hover:tw-bg-[#27272a]/50 tw-px-4 tw-py-2 tw-text-sm tw-text-[#a1a1aa] hover:tw-text-[#f4f4f5] tw-transition-colors" data-status="REJECTED" onclick="switchDashboardFilter('REJECTED')">
      <i class="bi bi-x-circle"></i> Rejected
      <span class="badge tw-ml-1 tw-rounded-full tw-bg-white/10 tw-px-2 tw-py-0.5 tw-text-[11px]" id="dashboard-badge-rejected">0</span>
    </button>
  </div>

  <!-- Search and Controls -->
  <div class="filters-bar tw-p-4 tw-flex tw-items-center tw-justify-between tw-gap-4 tw-bg-[#18181b] tw-border-b tw-border-[#27272a]">
    <div class="search-group tw-flex tw-items-center tw-gap-2 tw-flex-1">
      <i class="bi bi-search tw-text-[#a1a1aa]"></i>
      <input id="dashboardSearchBox" class="search-input tw-flex-1 tw-bg-transparent tw-border-0 tw-text-[#f4f4f5] focus:tw-outline-none" placeholder="Search subject, sender, or recipient..." oninput="filterDashboardEmails()" />
    </div>
    <div class="toolbar-actions tw-flex tw-items-center tw-gap-3">
      <label class="form-check tw-flex tw-items-center tw-gap-2 tw-text-sm tw-text-[#a1a1aa] tw-cursor-pointer">
        <input type="checkbox" class="form-check-input" id="dashboardAutoRefresh" onchange="toggleDashboardAutoRefresh(this.checked)">
        <span>Auto-refresh</span>
      </label>
      <button class="tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-font-medium tw-py-1.5 tw-px-3 hover:tw-bg-zinc-700 tw-transition-colors tw-flex tw-items-center tw-gap-2 tw-rounded-md tw-text-sm" type="button" onclick="loadDashboardEmails()">
        <i class="bi bi-arrow-clockwise"></i> Refresh
      </button>
    </div>
  </div>

  <!-- Bulk Actions Bar -->
  <div id="bulk-actions-bar" class="bulk-toolbar tw-hidden tw-sticky tw-top-2 tw-z-20 tw-flex tw-items-center tw-justify-between tw-gap-3 tw-rounded-xl tw-bg-sky-500/15 tw-border tw-border-sky-500/30 tw-backdrop-blur tw-p-3 tw-mx-4 tw-mt-3">
    <span id="bulk-selection-count" class="tw-text-sm tw-font-medium tw-text-[#f4f4f5]">0 selected</span>
    <div class="tw-flex tw-gap-2">
      <button class="tw-bg-emerald-500/90 hover:tw-bg-emerald-500 tw-text-white tw-font-medium tw-text-sm tw-rounded-md tw-border tw-border-emerald-600 tw-px-3 tw-py-1.5 tw-flex tw-items-center tw-gap-1" onclick="bulkReleaseEmails()">
        <i class="bi bi-send-check"></i> Release
      </button>
      <button class="tw-bg-rose-500/90 hover:tw-bg-rose-500 tw-text-white tw-font-medium tw-text-sm tw-rounded-md tw-border tw-border-rose-600 tw-px-3 tw-py-1.5 tw-flex tw-items-center tw-gap-1" onclick="bulkDiscardEmails()">
        <i class="bi bi-trash"></i> Discard
      </button>
      <button class="tw-bg-white/10 hover:tw-bg-white/20 tw-text-[#f4f4f5] tw-font-medium tw-text-sm tw-rounded-md tw-border tw-border-white/10 tw-px-3 tw-py-1.5" onclick="clearBulkSelection()">
        <i class="bi bi-x-circle"></i> Clear
      </button>
    </div>
  </div>

  <!-- Email Table -->
  <div class="tw-overflow-x-auto">
    <table class="email-table tw-w-full tw-text-sm">
      <thead class="tw-border-b tw-border-[#27272a]">
        <tr>
          <th class="col-select tw-p-3 tw-font-semibold tw-text-left tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider tw-text-xs">
            <input type="checkbox" id="select-all-emails" onchange="toggleSelectAll(this.checked)" class="tw-cursor-pointer">
          </th>
          <th class="tw-p-3 tw-font-semibold tw-text-left tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider tw-text-xs">Time</th>
          <th class="col-from tw-p-3 tw-font-semibold tw-text-left tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider tw-text-xs">Correspondents</th>
          <th class="col-subject tw-p-3 tw-font-semibold tw-text-left tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider tw-text-xs">Subject</th>
          <th class="col-status tw-p-3 tw-font-semibold tw-text-left tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider tw-text-xs">Status</th>
          <th class="col-actions tw-p-3 tw-font-semibold tw-text-left tw-text-[#a1a1aa] tw-uppercase tw-tracking-wider tw-text-xs">Actions</th>
        </tr>
      </thead>
      <tbody id="dashboardEmailTableBody" class="tw-divide-y tw-divide-[#27272a]">
        <!-- Dynamic content loaded via JavaScript -->
      </tbody>
    </table>
  </div>

  <!-- Loading Spinner -->
  <div id="dashboardLoadingSpinner" class="loading-spinner tw-flex tw-flex-col tw-items-center tw-gap-3 tw-text-[#a1a1aa] tw-py-10">
    <div class="spinner"></div>
    <p>Loading emails...</p>
  </div>

  <!-- Empty State -->
  <div id="dashboardEmptyState" class="empty-state tw-text-center tw-text-[#a1a1aa] tw-space-y-2 tw-p-10" style="display: none;">
    <i class="bi bi-inbox tw-text-4xl"></i>
    <p id="emptyStateMessage" class="tw-font-medium">No emails found</p>
    <p id="emptyStateHint" class="tw-text-sm tw-opacity-70"></p>
  </div>

  <!-- Pagination Controls -->
  <div id="paginationControls" class="tw-p-4 tw-border-t tw-border-[#27272a]" style="display: none;">
    <div class="tw-flex tw-justify-between tw-items-center tw-flex-wrap tw-gap-3">
      <div class="tw-text-[#9ca3af] tw-text-sm">
        Showing <span id="pagination-showing-start">0</span>-<span id="pagination-showing-end">0</span> of <span id="pagination-total">0</span> emails
      </div>
      <div class="tw-flex tw-gap-2 tw-items-center">
        <button class="tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-font-medium tw-py-1.5 tw-px-3 hover:tw-bg-zinc-700 tw-transition-colors tw-rounded-md tw-text-sm disabled:tw-opacity-50 disabled:tw-cursor-not-allowed" id="pagination-first" onclick="goToPage(1)" disabled>
          <i class="bi bi-chevron-double-left"></i> First
        </button>
        <button class="tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-font-medium tw-py-1.5 tw-px-3 hover:tw-bg-zinc-700 tw-transition-colors tw-rounded-md tw-text-sm disabled:tw-opacity-50 disabled:tw-cursor-not-allowed" id="pagination-prev" onclick="goToPage(currentPage - 1)" disabled>
          <i class="bi bi-chevron-left"></i> Previous
        </button>
        <div id="pagination-numbers" class="tw-flex tw-gap-1">
          <!-- Page numbers inserted here -->
        </div>
        <button class="tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-font-medium tw-py-1.5 tw-px-3 hover:tw-bg-zinc-700 tw-transition-colors tw-rounded-md tw-text-sm disabled:tw-opacity-50 disabled:tw-cursor-not-allowed" id="pagination-next" onclick="goToPage(currentPage + 1)" disabled>
          Next <i class="bi bi-chevron-right"></i>
        </button>
        <button class="tw-bg-[#27272a] tw-border tw-border-zinc-700/50 tw-text-[#f4f4f5] tw-font-medium tw-py-1.5 tw-px-3 hover:tw-bg-zinc-700 tw-transition-colors tw-rounded-md tw-text-sm disabled:tw-opacity-50 disabled:tw-cursor-not-allowed" id="pagination-last" onclick="goToPage(totalPages)" disabled>
          Last <i class="bi bi-chevron-double-right"></i>
        </button>
      </div>
    </div>
  </div>
</div>
</div><!-- /#dashboard-page -->
{% endblock %}

{% block extra_js %}
<script>
const currentAccountId = '{{ selected_account_id or "" }}';
const { renderTimeCell, applyTimeFormatting, escapeHtml } = window.MailOps;

applyTimeFormatting();

let dashboardAggregateCounts = null;
let dashboardDatasetCounts = { ALL: 0, HELD: 0, RELEASED: 0, REJECTED: 0 };

function updateStatsFromPayload(payload) {
  if (!payload) return;
  const toNumber = (value) => {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : 0;
  };

  const hasAggregateFields = ['total', 'held', 'released', 'rejected', 'discarded'].some(
    (key) => Object.prototype.hasOwnProperty.call(payload, key)
  );

  // Ignore partial SSE payloads that only contain incremental fields (e.g., pending count)
  if (!hasAggregateFields) {
    return;
  }

  const heldTotal = toNumber(payload.held);
  const releasedTotal = toNumber(payload.released);
  const totalCandidate = toNumber(payload.total);
  const rejectedTotal = toNumber(payload.rejected) + toNumber(payload.discarded);
  const totalValue = totalCandidate > 0 ? totalCandidate : heldTotal + releasedTotal + rejectedTotal;

  document.getElementById('statTotal').textContent = totalValue;
  document.getElementById('statHeld').textContent = heldTotal;
  document.getElementById('statReleased').textContent = releasedTotal;

  dashboardAggregateCounts = {
    ALL: totalValue,
    HELD: heldTotal,
    RELEASED: releasedTotal,
    REJECTED: rejectedTotal
  };
  applyDashboardBadgeCounts();
}

function switchAccount(accountId) {
  currentAccountId = accountId;
  const searchParams = accountId ? '?account_id=' + accountId : '';
  window.location.href = `/dashboard${searchParams}`;
}

// Load stats with account filtering
async function loadStats() {
  try {
    let url = '/api/unified-stats';
    if (currentAccountId) {
      url += '?account_id=' + currentAccountId;
    }

    const response = await fetch(url);
    if (!response.ok) return;

    const data = await response.json();
    const payload = data && data.unified ? data.unified : data;
    updateStatsFromPayload(payload || {});
  } catch (error) {
    console.error('Error loading stats:', error);
  }
}

// Load watcher states for all accounts
async function loadWatchersMap() {
  try {
    const r = await fetch('/api/watchers/overview');
    if (!r.ok) return;
    const j = await r.json();
    watchersMap = {};
    (j.accounts || []).forEach(a => {
      watchersMap[a.id] = (a.watcher && a.watcher.state) || (a.is_active ? 'active' : 'stopped');
    });
  } catch (e) { /* ignore */ }
}

// Dashboard email management
let dashboardEmails = [];
let dashboardActiveFilter = 'ALL';
let dashboardAutoRefreshTimer = null;
let watchersMap = {};
const { escapeHtml } = window.MailOps || { escapeHtml: (s) => String(s).replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])) };

// Pagination state
let currentPage = 1;
let itemsPerPage = 50;
let totalPages = 1;
let filteredEmails = [];

// Load recent emails with account filtering
async function loadDashboardEmails() {
  const loadingSpinner = document.getElementById('dashboardLoadingSpinner');
  const emailTable = document.querySelector('.email-table');

  try {
    // Show loading spinner
    if (loadingSpinner) loadingSpinner.classList.add('active');
    if (emailTable) emailTable.style.opacity = '0.5';

    let url = '/api/inbox';
    const params = new URLSearchParams();
    if (currentAccountId) {
      params.append('account_id', currentAccountId);
    }
    // Remove limit to load all emails for client-side pagination
    params.append('limit', '1000');

    const response = await fetch(url + '?' + params.toString());
    if (!response.ok) throw new Error('Failed to fetch emails');

    const data = await response.json();
    dashboardEmails = data.messages || [];

    updateDashboardBadges(dashboardEmails);
    currentPage = 1; // Reset to first page
    filterDashboardEmails(dashboardActiveFilter);
  } catch (error) {
    console.error('Error loading emails:', error);
  } finally {
    // Hide loading spinner
    if (loadingSpinner) loadingSpinner.classList.remove('active');
    if (emailTable) emailTable.style.opacity = '1';
  }
}

// Restart watcher for a specific account
async function restartWatcherFor(accountId) {
  if (!accountId) {
    if (window.showError) showError('No account ID available for watcher restart');
    return;
  }
  try {
    const r = await fetch(`/api/accounts/${accountId}/monitor/restart`, { method: 'POST' });
    const j = await r.json();
    if (!j.success) {
      throw new Error(j.error || 'Failed');
    }
    if (window.showSuccess) showSuccess('Watcher restarted');
    await loadWatchersMap();
    filterDashboardEmails(dashboardActiveFilter);
  } catch (e) {
    if (window.showError) showError('Restart failed (admin required?)');
  }
}

function updateDashboardBadges(emails) {
  const counts = { ALL: 0, HELD: 0, RELEASED: 0, REJECTED: 0 };
  emails.forEach(email => {
    counts.ALL++;
    let status = (email.interception_status || email.status || '').toUpperCase();
    if (status === 'PENDING') status = 'HELD';
    if (status === 'APPROVED' || status === 'DELIVERED') status = 'RELEASED';
    if (status === 'DISCARDED') status = 'REJECTED';
    if (counts[status] !== undefined) counts[status]++;
  });
  dashboardDatasetCounts = counts;
  applyDashboardBadgeCounts();
}

function applyDashboardBadgeCounts() {
  const dataset = dashboardDatasetCounts || {};
  const aggregate = dashboardAggregateCounts || null;
  const useAggregate = aggregate && (aggregate.ALL || aggregate.HELD || aggregate.RELEASED || aggregate.REJECTED);

  const finalAll = useAggregate ? aggregate.ALL : (dataset.ALL || 0);
  const finalHeld = useAggregate ? aggregate.HELD : (dataset.HELD || 0);
  const finalReleased = useAggregate ? aggregate.RELEASED : (dataset.RELEASED || 0);
  const finalRejected = useAggregate ? aggregate.REJECTED : (dataset.REJECTED || 0);

  document.getElementById('dashboard-badge-all').textContent = finalAll;
  document.getElementById('dashboard-badge-held').textContent = finalHeld;
  document.getElementById('dashboard-badge-released').textContent = finalReleased;
  document.getElementById('dashboard-badge-rejected').textContent = finalRejected;
}

function switchDashboardFilter(status) {
  dashboardActiveFilter = status;
  document.querySelectorAll('.status-tab').forEach(tab => {
    tab.classList.toggle('active', tab.dataset.status === status);
  });
  filterDashboardEmails(status);
}

function filterDashboardEmails(statusFilter = dashboardActiveFilter) {
  const searchTerm = document.getElementById('dashboardSearchBox').value.toLowerCase();
  let filtered = dashboardEmails;

  // Filter by status
  if (statusFilter && statusFilter !== 'ALL') {
    filtered = filtered.filter(email => {
      let status = (email.interception_status || email.status || '').toUpperCase();
      if (status === 'PENDING') status = 'HELD';
      if (status === 'APPROVED' || status === 'DELIVERED') status = 'RELEASED';
      if (status === 'DISCARDED') status = 'REJECTED';
      return status === statusFilter;
    });
  }

  // Filter by search
  if (searchTerm) {
    filtered = filtered.filter(email => {
      const subject = (email.subject || '').toLowerCase();
      const sender = (email.sender || '').toLowerCase();
      const recipients = Array.isArray(email.recipients) ? email.recipients.join(' ').toLowerCase() : (email.recipients || '').toLowerCase();
      return subject.includes(searchTerm) || sender.includes(searchTerm) || recipients.includes(searchTerm);
    });
  }

  // Store filtered results for pagination
  filteredEmails = filtered;
  totalPages = Math.max(1, Math.ceil(filteredEmails.length / itemsPerPage));

  // Ensure currentPage is valid
  if (currentPage > totalPages) {
    currentPage = totalPages;
  }

  renderDashboardEmailsWithPagination();
  updatePaginationControls();
}

function renderDashboardEmailsWithPagination() {
  const tbody = document.getElementById('dashboardEmailTableBody');
  const emptyState = document.getElementById('dashboardEmptyState');
  const paginationControls = document.getElementById('paginationControls');
  const emptyMessage = document.getElementById('emptyStateMessage');
  const emptyHint = document.getElementById('emptyStateHint');

  if (!filteredEmails || filteredEmails.length === 0) {
    tbody.innerHTML = '';
    emptyState.style.display = 'block';
    paginationControls.style.display = 'none';

    // Set contextual empty state message
    const searchTerm = document.getElementById('dashboardSearchBox').value;
    if (searchTerm) {
      emptyMessage.textContent = `No emails matching "${searchTerm}"`;
      emptyHint.textContent = 'Try a different search term or clear the search filter';
    } else if (dashboardActiveFilter !== 'ALL') {
      emptyMessage.textContent = `No ${dashboardActiveFilter.toLowerCase()} emails`;
      emptyHint.textContent = 'Try selecting a different status filter';
    } else if (dashboardEmails.length === 0) {
      emptyMessage.textContent = 'No emails yet';
      emptyHint.textContent = 'Emails will appear here once they are intercepted by the system';
    } else {
      emptyMessage.textContent = 'No emails found';
      emptyHint.textContent = '';
    }

    return;
  }

  emptyState.style.display = 'none';
  paginationControls.style.display = 'block';
  tbody.innerHTML = '';

  // Calculate pagination
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = Math.min(startIndex + itemsPerPage, filteredEmails.length);
  const pageEmails = filteredEmails.slice(startIndex, endIndex);

  pageEmails.forEach(email => {
    const tr = document.createElement('tr');
    tr.className = 'hover:tw-bg-[#27272a]/50 tw-transition-colors';
    tr.dataset.emailId = email.id;

    let status = (email.interception_status || email.status || 'UNKNOWN').toUpperCase();
    if (status === 'PENDING') status = 'HELD';
    if (status === 'APPROVED' || status === 'DELIVERED') status = 'RELEASED';
    if (status === 'DISCARDED') status = 'REJECTED';
    const statusLabel = status.charAt(0) + status.slice(1).toLowerCase();

    const recipients = Array.isArray(email.recipients) ? email.recipients.join(', ') : (email.recipients || '');
    const senderDisplay = escapeHtml(email.sender || 'Unknown');
    const recipientDisplay = escapeHtml(recipients || 'â€”');
    const subjectDisplay = escapeHtml(email.subject || '(No Subject)');
    const createdAtCell = renderTimeCell(email.created_at, 'N/A');

    // Determine actions
    let actions = '';
    if (status === 'HELD') {
      actions = `
        <button class="action-btn action-edit" onclick="event.stopPropagation(); window.location.href='/email/${email.id}'" title="Edit">
          <i class="bi bi-pencil"></i>
        </button>
        <button class="action-btn action-release" onclick="event.stopPropagation(); releaseEmailDashboard(${email.id})" title="Release">
          <i class="bi bi-unlock"></i>
        </button>
        <button class="action-btn action-discard" onclick="event.stopPropagation(); discardEmailDashboard(${email.id})" title="Discard">
          <i class="bi bi-trash"></i>
        </button>
      `;
    } else {
      actions = `
        <button class="action-btn action-view" onclick="event.stopPropagation(); window.location.href='/email/${email.id}'" title="View">
          <i class="bi bi-eye"></i>
        </button>
      `;
    }

    // Generate watcher badge
    const watcherStateRaw = watchersMap[email.account_id] || 'unknown';
    const watcherClass = watcherStateRaw === 'active' ? 'active' : (watcherStateRaw === 'stopped' ? 'stopped' : 'unknown');
    let watcherLabel = 'Unknown';
    if (watcherStateRaw === 'active') {
      watcherLabel = 'Active';
    } else if (watcherStateRaw === 'stopped') {
      watcherLabel = 'Stopped';
    } else if (watcherStateRaw && watcherStateRaw !== 'unknown') {
      watcherLabel = watcherStateRaw.charAt(0).toUpperCase() + watcherStateRaw.slice(1);
    }
    const watcherClassSafe = escapeHtml(watcherClass);
    const watcherBadge = `<span class="watcher-chip ${watcherClassSafe}" title="Watcher state">${escapeHtml(watcherLabel)}</span>`;

    tr.innerHTML = `
      <td onclick="event.stopPropagation()">
        <input type="checkbox" class="email-checkbox" data-email-id="${email.id}" onchange="updateBulkSelection()" style="cursor:pointer;">
      </td>
      <td>${createdAtCell}</td>
      <td>
        <div class="correspondent-cell">
          <div class="correspondent-line">
            <span class="correspondent-label">FROM</span>
            <span class="correspondent-value">${senderDisplay}</span>
          </div>
          <div class="correspondent-line">
            <span class="correspondent-label">TO</span>
            <span class="correspondent-value">${recipientDisplay}</span>
          </div>
        </div>
      </td>
      <td onclick="window.location.href='/email/${email.id}'" style="cursor: pointer;">
        <div class="subject-cell">${subjectDisplay}</div>
      </td>
      <td>
        <div class="status-cell">
          <div class="status-main"><span class="status-badge status-${status}">${statusLabel}</span></div>
          <div class="status-meta">${watcherBadge}
            <button type="button" class="status-restart" title="Restart watcher" onclick="restartWatcherFor(${email.account_id})"><i class="bi bi-arrow-repeat"></i></button>
          </div>
        </div>
      </td>
      <td>
        <div class="action-buttons">
          ${actions}
        </div>
      </td>
    `;

    tbody.appendChild(tr);
  });

  applyTimeFormatting(tbody);
}

async function releaseEmailDashboard(emailId) {
  const confirmed = window.confirmToast
    ? await new Promise(resolve => confirmToast('Release this email to the inbox?', () => resolve(true), () => resolve(false)))
    : confirm('Release this email to the inbox?');
  if (!confirmed) return;
  try {
    const response = await fetch(`/api/interception/release/${emailId}`, { method: 'POST' });
    const data = await response.json();
    if (data.success) {
      if (window.showSuccess) showSuccess('Email released successfully');
      await loadDashboardEmails();
      await loadStats();
    } else {
      if (window.showError) showError(data.error || 'Failed to release email');
    }
  } catch (error) {
    console.error('Error releasing email:', error);
    if (window.showError) showError('Failed to release email');
  }
}

async function discardEmailDashboard(emailId) {
  const confirmed = window.confirmToast
    ? await new Promise(resolve => confirmToast('Discard this email permanently?', () => resolve(true), () => resolve(false)))
    : confirm('Discard this email permanently?');
  if (!confirmed) return;
  try {
    const response = await fetch(`/api/interception/discard/${emailId}`, { method: 'POST' });
    const data = await response.json();
    if (data.success) {
      if (window.showSuccess) showSuccess('Email discarded');
      await loadDashboardEmails();
      await loadStats();
    } else {
      if (window.showError) showError(data.error || 'Failed to discard email');
    }
  } catch (error) {
    console.error('Error discarding email:', error);
    if (window.showError) showError('Failed to discard email');
  }
}

function toggleDashboardAutoRefresh(enabled) {
  if (dashboardAutoRefreshTimer) {
    clearInterval(dashboardAutoRefreshTimer);
    dashboardAutoRefreshTimer = null;
  }

  if (enabled) {
    dashboardAutoRefreshTimer = setInterval(() => {
      loadDashboardEmails();
      loadStats();
    }, 10000); // Refresh every 10 seconds
  }

  localStorage.setItem('dashboard_auto_refresh', enabled ? 'true' : 'false');
}

// Initialize and set up auto-refresh
loadStats();
loadWatchersMap();
loadDashboardEmails();

// Restore auto-refresh preference
const dashboardAutoRefreshPref = localStorage.getItem('dashboard_auto_refresh');
if (dashboardAutoRefreshPref === 'true') {
  document.getElementById('dashboardAutoRefresh').checked = true;
  toggleDashboardAutoRefresh(true);
}

// Auto-refresh every 30 seconds
setInterval(() => {
  loadStats();
  loadWatchersMap();
  loadDashboardEmails();
}, 30000);

// Try to use SSE for real-time updates
try {
  const eventSource = new EventSource('/stream/stats');

  eventSource.onmessage = (event) => {
    try {
      const raw = JSON.parse(event.data);
      const payload = raw && raw.unified ? raw.unified : raw;
      const targetAccount = raw && raw.account_id !== undefined
        ? String(raw.account_id)
        : (payload && payload.account_id !== undefined ? String(payload.account_id) : null);

      if (!currentAccountId || targetAccount === null || String(currentAccountId) === targetAccount) {
        updateStatsFromPayload(payload || {});
      }
    } catch (err) {
      console.warn('SSE parse error:', err);
    }
  };

  eventSource.onerror = () => {
    eventSource.close();
    // Fall back to polling
  };
} catch (error) {
  console.warn('SSE not supported, using polling');
}

// Email search functionality
function performEmailSearch() {
  const query = document.getElementById('email-search-input').value.trim();
  if (!query) return;

  const accountId = document.getElementById('account-selector')?.value || '';
  const searchBtn = document.getElementById('email-search-btn');
  const clearBtn = document.getElementById('email-search-clear');
  const statusDiv = document.getElementById('email-search-status');
  const resultsDiv = document.getElementById('email-search-results');

  searchBtn.disabled = true;
  statusDiv.textContent = 'Searching...';
  resultsDiv.style.display = 'block';

  let url = `/api/emails/search?q=${encodeURIComponent(query)}`;
  if (accountId) url += `&account_id=${accountId}`;

  fetch(url)
    .then(r => r.json())
    .then(data => {
      statusDiv.textContent = `Found ${data.count} email(s) matching "${data.query}"`;
      clearBtn.style.display = 'inline-block';

      // Hide status tabs and display search results
      document.querySelector('.status-tabs').style.display = 'none';

      // Update filteredEmails with search results and render
      filteredEmails = data.emails || [];
      currentPage = 1;
      renderDashboardEmailsWithPagination();
      updatePaginationControls();
    })
    .catch(err => {
      console.error('Search error:', err);
      statusDiv.textContent = 'Search failed. Please try again.';
      statusDiv.className = 'alert alert-danger';
    })
    .finally(() => {
      searchBtn.disabled = false;
    });
}

function clearEmailSearch() {
  document.getElementById('email-search-input').value = '';
  document.getElementById('email-search-results').style.display = 'none';
  document.getElementById('email-search-clear').style.display = 'none';
  document.querySelector('.status-tabs').style.display = 'flex';
  switchDashboardFilter('ALL'); // Reload all emails
}

// Allow Enter key to search
document.addEventListener('DOMContentLoaded', function() {
  const searchInput = document.getElementById('email-search-input');
  if (searchInput) {
    searchInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') performEmailSearch();
    });
  }
});

// Bulk operations
let selectedEmailIds = new Set();

function toggleSelectAll(checked) {
  const checkboxes = document.querySelectorAll('.email-checkbox');
  checkboxes.forEach(cb => {
    cb.checked = checked;
    if (checked) {
      selectedEmailIds.add(parseInt(cb.dataset.emailId));
    } else {
      selectedEmailIds.delete(parseInt(cb.dataset.emailId));
    }
  });
  updateBulkSelection();
}

function updateBulkSelection() {
  selectedEmailIds.clear();
  document.querySelectorAll('.email-checkbox:checked').forEach(cb => {
    selectedEmailIds.add(parseInt(cb.dataset.emailId));
  });

  const count = selectedEmailIds.size;
  const bulkBar = document.getElementById('bulk-actions-bar');
  const countSpan = document.getElementById('bulk-selection-count');
  const selectAllCheckbox = document.getElementById('select-all-emails');

  if (count > 0) {
    bulkBar.classList.add('show');
    countSpan.textContent = `${count} selected`;
  } else {
    bulkBar.classList.remove('show');
    selectAllCheckbox.checked = false;
  }
}

function clearBulkSelection() {
  document.querySelectorAll('.email-checkbox').forEach(cb => cb.checked = false);
  selectedEmailIds.clear();
  updateBulkSelection();
}

async function bulkReleaseEmails() {
  if (selectedEmailIds.size === 0) return;

  const confirmed = window.confirmToast
    ? await new Promise(resolve => confirmToast(`Release ${selectedEmailIds.size} email(s) to inbox?`, () => resolve(true), () => resolve(false)))
    : confirm(`Release ${selectedEmailIds.size} email(s) to inbox?`);
  if (!confirmed) return;

  try {
    const res = await fetch('/api/emails/bulk-release', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({email_ids: Array.from(selectedEmailIds)})
    });

    const data = await res.json();
    if (res.ok) {
      if (window.showToast) {
        showToast('success', `Released ${data.released} email(s)`);
      } else if (window.showSuccess) {
        showSuccess(`Released ${data.released} email(s)`);
      }
      clearBulkSelection();
      loadDashboardEmails();
    } else {
      if (window.showToast) {
        showToast('error', data.error || 'Bulk release failed');
      } else if (window.showError) {
        showError(data.error || 'Bulk release failed');
      }
    }
  } catch (err) {
    console.error('Bulk release error:', err);
    if (window.showToast) {
      showToast('error', 'Bulk release failed');
    } else if (window.showError) {
      showError('Bulk release failed');
    }
  }
}

async function bulkDiscardEmails() {
  if (selectedEmailIds.size === 0) return;

  const confirmed = window.confirmToast
    ? await new Promise(resolve => confirmToast(`Discard ${selectedEmailIds.size} email(s)? This cannot be undone.`, () => resolve(true), () => resolve(false)))
    : confirm(`Discard ${selectedEmailIds.size} email(s)? This cannot be undone.`);
  if (!confirmed) return;

  try {
    const res = await fetch('/api/emails/bulk-discard', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({email_ids: Array.from(selectedEmailIds)})
    });

    const data = await res.json();
    if (res.ok) {
      if (window.showToast) {
        showToast('success', `Discarded ${data.discarded} email(s)`);
      } else if (window.showSuccess) {
        showSuccess(`Discarded ${data.discarded} email(s)`);
      }
      clearBulkSelection();
      loadDashboardEmails();
    } else {
      if (window.showToast) {
        showToast('error', data.error || 'Bulk discard failed');
      } else if (window.showError) {
        showError(data.error || 'Bulk discard failed');
      }
    }
  } catch (err) {
    console.error('Bulk discard error:', err);
    if (window.showToast) {
      showToast('error', 'Bulk discard failed');
    } else if (window.showError) {
      showError('Bulk discard failed');
    }
  }
}

// Pagination functions
function goToPage(page) {
  if (page < 1 || page > totalPages || page === currentPage) return;
  currentPage = page;
  renderDashboardEmailsWithPagination();
  updatePaginationControls();

  // Scroll to top of email list
  const emailsPanel = document.querySelector('.recent-emails-panel');
  if (emailsPanel) {
    emailsPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

function updatePaginationControls() {
  const paginationControls = document.getElementById('paginationControls');
  if (!paginationControls) return;

  // Update showing text
  const startIndex = (currentPage - 1) * itemsPerPage + 1;
  const endIndex = Math.min(currentPage * itemsPerPage, filteredEmails.length);
  document.getElementById('pagination-showing-start').textContent = filteredEmails.length === 0 ? 0 : startIndex;
  document.getElementById('pagination-showing-end').textContent = endIndex;
  document.getElementById('pagination-total').textContent = filteredEmails.length;

  // Update button states
  document.getElementById('pagination-first').disabled = currentPage === 1;
  document.getElementById('pagination-prev').disabled = currentPage === 1;
  document.getElementById('pagination-next').disabled = currentPage === totalPages;
  document.getElementById('pagination-last').disabled = currentPage === totalPages;

  // Render page numbers
  const paginationNumbers = document.getElementById('pagination-numbers');
  paginationNumbers.innerHTML = '';

  if (totalPages <= 7) {
    // Show all pages
    for (let i = 1; i <= totalPages; i++) {
      paginationNumbers.appendChild(createPageButton(i));
    }
  } else {
    // Show first, last, current and neighbors
    paginationNumbers.appendChild(createPageButton(1));

    if (currentPage > 3) {
      paginationNumbers.appendChild(createEllipsis());
    }

    for (let i = Math.max(2, currentPage - 1); i <= Math.min(currentPage + 1, totalPages - 1); i++) {
      paginationNumbers.appendChild(createPageButton(i));
    }

    if (currentPage < totalPages - 2) {
      paginationNumbers.appendChild(createEllipsis());
    }

    paginationNumbers.appendChild(createPageButton(totalPages));
  }
}

function createPageButton(pageNum) {
  const btn = document.createElement('button');
  btn.className = 'btn btn-sm ' + (pageNum === currentPage ? 'btn-primary' : 'btn-secondary');
  btn.textContent = pageNum;
  btn.onclick = () => goToPage(pageNum);
  btn.style.minWidth = '36px';
  return btn;
}

function createEllipsis() {
  const span = document.createElement('span');
  span.textContent = '...';
  span.style.padding = '0 8px';
  span.style.color = '#9ca3af';
  return span;
}

</script>
{% endblock %}
