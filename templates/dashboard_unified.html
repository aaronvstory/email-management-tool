{% extends "base.html" %}

{% block title %}Dashboard - Email Management Tool{% endblock %}

{% block extra_css %}
{# Use global theme-dark.css tokens/components #}
{% endblock %}

{% block content %}
<div class="page-header d-flex justify-content-between align-items-center">
    <h1><i class="bi bi-speedometer2"></i> Unified Dashboard</h1>
    <div class="header-actions btn-group-unified">
        <button class="btn btn-primary-modern" onclick="location.reload()">
            <i class="bi bi-arrow-clockwise"></i> Refresh
        </button>
    </div>
</div>

<!-- Account Selector -->
<div class="content-section compact">
    <div class="row align-items-center">
        <div class="col-md-6">
            <label class="form-label fw-bold">Select Account:</label>
            <select class="form-select" id="accountSelector" onchange="switchAccount(this.value)">
                <option value="">All Accounts (Overview)</option>
                {% for account in accounts %}
                <option value="{{ account.id }}" {% if selected_account_id == account.id|string %}selected{% endif %}>
                    {{ account.account_name }} ({{ account.email_address }})
                </option>
                {% endfor %}
            </select>
        </div>
        <div class="col-md-6 text-end">
            {% if selected_account_id %}
            {% for account in accounts %}
                {% if account.id|string == selected_account_id %}
                <span class="chip {% if account.is_active %}chip-ok{% else %}chip-bad{% endif %}">
                    {% if account.is_active %}active{% else %}inactive{% endif %}
                </span>
                <span class="text-muted ms-2">
                    Last checked: {{ account.last_checked or 'Never' }}
                </span>
                {% endif %}
            {% endfor %}
            {% endif %}
        </div>
    </div>
</div>

<!-- Tabs removed: the Dashboard is a single view -->

<!-- Single Dashboard view -->
<div>
      <div class="content-section">
        <div class="content-section-header">
          <div class="section-title">System Stats</div>
        </div>
        <div class="metric-grid" id="statsGrid">
          <div class="stat-card-modern">
            <div class="stat-label">Total</div>
            <div class="stat-value" id="statTotal">-</div>
          </div>
          <div class="stat-card-modern">
            <div class="stat-label">Pending (Outbound)</div>
            <div class="stat-value" id="statPending">-</div>
          </div>
          <div class="stat-card-modern">
            <div class="stat-label">Held (Inbound)</div>
            <div class="stat-value" id="statHeld">-</div>
          </div>
          <div class="stat-card-modern">
            <div class="stat-label">Released / Delivered</div>
            <div class="stat-value" id="statReleased">-</div>
          </div>
          <div class="stat-card-modern">
            <div class="stat-label">Latency <i class="bi bi-info-circle" style="font-size:.8rem;opacity:.8;"></i></div>
            <div class="stat-value" id="latencyBucket" style="font-size:.95rem;">—</div>
          </div>
        </div>
      </div>

      <div class="content-section" style="margin-top:20px;">
        <div class="content-section-header">
          <div class="section-title">Recent Emails</div>
        </div>
        <div class="table-responsive">
          <table class="table table-modern table-hover mb-0">
            <thead>
              <tr>
                <th>From</th>
                <th>To</th>
                <th>Subject</th>
                <th>Status</th>
                <th>Time</th>
                <th></th>
              </tr>
            </thead>
            <tbody>
              {% for email in recent_emails %}
              <tr>
                <td>{{ email.sender }}</td>
                <td>{{ email.recipients }}</td>
                <td>{{ email.subject[:50] }}{% if email.subject|length > 50 %}...{% endif %}</td>
                <td>
                  <span class="chip
                    {% if email.status|lower in ['released','delivered'] %}chip-released
                    {% elif email.status|lower in ['pending','queued'] %}chip-pending
                    {% elif email.status|lower in ['sent'] %}chip-sent
                    {% else %}chip-error{% endif %}">
                    {{ email.status }}
                  </span>
                </td>
                <td class="subtle">{{ email.created_at }}</td>
                <td><a href="/email/{{ email.id }}" class="btn btn-secondary btn-sm btn-icon"><i class="bi bi-eye"></i></a></td>
              </tr>
              {% else %}
              <tr>
                <td colspan="6" class="text-center subtle" style="padding:24px;">No emails yet. <a href="/compose">Compose your first email</a></td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
</div>

<script>
function switchAccount(accountId) {
  const url = accountId ? `/dashboard?account_id=${accountId}` : '/dashboard';
  window.location.href = url;
}

let useSSE = true;

// Apply stats to UI (works for both polling and SSE)
function applyStats(j) {
    const m = (id, v) => {
        const el = document.getElementById(id);
        if (el) el.textContent = v;
    };
    const u = j.unified || j;
    m('statTotal', u.total ?? 0);
    m('statPending', u.pending ?? 0);
    m('statHeld', u.held ?? 0);
    m('statReleased', u.released ?? 0);

    // Update latency if available
    if (j.latency) {
        const l = j.latency;
        const el = document.getElementById('latencyBucket');
        if (el) {
            if (!l.count) {
                el.textContent = '—';
            } else {
                el.textContent = `${l.p50}ms p50 • ${l.p95}ms p95 • ${l.max}ms max`;
            }
        }
    }
}

// Load unified stats + latency from API (fallback for non-SSE)
async function loadUnifiedStats() {
    try {
        const [uResp, lResp] = await Promise.all([
            fetch('/api/unified-stats'),
            fetch('/api/latency-stats')
        ]);
        if (!uResp.ok) return;
        const unified = await uResp.json();
        const latency = lResp.ok ? await lResp.json() : null;
        applyStats({ unified, latency });
    } catch(e) {
        console.warn('Stats error:', e);
    }
}

// Start SSE connection for live updates
function startSSE() {
    try {
        const es = new EventSource('/stream/stats');
        es.onmessage = (e) => {
            try {
                applyStats(JSON.parse(e.data));
            } catch(err) {
                console.warn('SSE parse error:', err);
            }
        };
        es.onerror = () => {
            console.warn('SSE connection failed, falling back to polling');
            es.close();
            useSSE = false;
            setInterval(loadUnifiedStats, 10000);
        };
    } catch(e) {
        console.warn('SSE not supported, using polling');
        useSSE = false;
        setInterval(loadUnifiedStats, 10000);
    }
}

// Initialize stats loading on page load
if (document.getElementById('statsGrid')) {
    startSSE();
    if (!useSSE) {
        loadUnifiedStats();
    }
}

function runDiagnostics(accountId) {
    const resultsDiv = document.getElementById('diagnosticsResults');
    resultsDiv.innerHTML = '<div class="spinner-border" role="status"><span class="visually-hidden">Running diagnostics...</span></div>';
    
    fetch(`/api/diagnostics/${accountId}`)
        .then(response => response.json())
        .then(data => {
            let html = '<div class="mt-3">';
            
            // SMTP Test
            html += '<div class="alert ' + (data.smtp_test.success ? 'alert-success' : 'alert-danger') + '">';
            html += '<strong>SMTP:</strong> ' + data.smtp_test.message;
            html += '</div>';
            
            // IMAP Test
            html += '<div class="alert ' + (data.imap_test.success ? 'alert-success' : 'alert-danger') + '">';
            html += '<strong>IMAP:</strong> ' + data.imap_test.message;
            html += '</div>';
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        })
        .catch(error => {
            resultsDiv.innerHTML = '<div class="alert alert-danger">Error running diagnostics: ' + error + '</div>';
        });
}

function testAccount(accountId) {
    if (window.showInfo) showInfo('Testing account ' + accountId);
    fetch('/api/accounts/' + accountId + '/test', { method: 'POST' })
      .then(r => r.json())
      .then(data => {
        if (data && data.success) {
          if (window.showSuccess) showSuccess('Account test successful');
        } else {
          const msg = (data && (data.error || (data.smtp && data.smtp.message) || (data.imap && data.imap.message))) || 'Test failed';
          if (window.showError) showError('Account test failed: ' + msg);
        }
      })
      .catch(err => { if (window.showError) showError('Error testing account: ' + err.message); });
}

function editAccount(accountId) {
    // Route to Accounts page; editing handled in that view
    window.location.href = `/accounts?edit=${accountId}`;
}
</script>
{% endblock %}